# -*- coding: utf-8 -*-
"""Seminar 1: Optimizing-Models-in-Pytorch-DataParallel

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11O9oX6ULN2ERXM4pynsTmTYVIbBaCkC3
"""

import torch
import torch.nn as nn
import torch.optim as optim
from torch.optim import lr_scheduler
from torchvision import datasets, transforms
from torchvision.models import resnet18, ResNet18_Weights
from torch.utils.data import DataLoader
import matplotlib.pyplot as plt
import torch.distributed as dist
import time
import os


# Parameters
data_dir = 'chest_xray'  # Directory containing the data
batch_size = 16          # Increased batch size for DataParallel
num_workers = 2
num_epochs = 10
learning_rate = 1e-3

# Check if the file exists
if not os.path.exists('ChestXRay2017.zip'):
    # Download the file using gdown
    subprocess.run(['gdown', '--fuzzy', 'https://drive.google.com/file/d/1jf1XvAeXPD4XAerknz5inxM0StuCNbyX/view?usp=sharing'])
    # Unzip the file
    subprocess.run(['unzip', '-qq', 'ChestXRay2017.zip'])


# Data transformations
data_transforms = {
    'train': transforms.Compose([
        transforms.RandomResizedCrop(224),
        transforms.RandomHorizontalFlip(),
        transforms.ToTensor(),
        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
    ]),
    'test': transforms.Compose([
        transforms.Resize(256),
        transforms.CenterCrop(224),
        transforms.ToTensor(),
        transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
    ]),
}

# Data loaders
image_datasets = {x: datasets.ImageFolder(os.path.join(data_dir, x), data_transforms[x]) for x in ['train', 'test']}
dataloaders = {x: DataLoader(image_datasets[x], batch_size=batch_size, shuffle=True, num_workers=num_workers) for x in ['train', 'test']}
dataset_sizes = {x: len(image_datasets[x]) for x in ['train', 'test']}

# Model setup
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
model = resnet18(weights=ResNet18_Weights.DEFAULT)
model.to(device)

print("Number of GPUs available:", torch.cuda.device_count())

# Loss function and optimizer
criterion = nn.CrossEntropyLoss()
optimizer = optim.SGD(model.parameters(), lr=learning_rate, momentum=0.9)
scheduler = lr_scheduler.StepLR(optimizer, step_size=7, gamma=0.1)

def train_model(model, dataloader, criterion, optimizer, num_epochs=10):
    total_start_time = time.time()  # Start timing for the entire training process

    for epoch in range(num_epochs):
        model.train()  # Set model to training mode
        running_loss = 0.0
        running_corrects = 0

        # Iterate over data in the training set
        for inputs, labels in dataloaders['train']:
            inputs = inputs.to(device)
            labels = labels.to(device)

            # Zero the parameter gradients
            optimizer.zero_grad()

            # Forward pass
            outputs = model(inputs)
            _, preds = torch.max(outputs, 1)
            loss = criterion(outputs, labels)

            # Backward pass and optimize
            loss.backward()
            optimizer.step()

            # Statistics
            running_loss += loss.item() * inputs.size(0)
            running_corrects += torch.sum(preds == labels.data)

        # Learning rate scheduler step
        scheduler.step()

        # Calculate and print epoch loss and accuracy
        epoch_loss = running_loss / len(dataloaders['train'].dataset)
        epoch_acc = running_corrects.double() / len(dataloaders['train'].dataset)
        print('Train Epoch [{}/{}] - Loss: {:.6f}, Acc: {:.6f}'.format(epoch + 1, num_epochs, epoch_loss, epoch_acc))

    total_training_time = time.time() - total_start_time  # Calculate the total training time
    return total_training_time

single_gpu_time = train_model(model, dataloaders, criterion, optimizer)

"""# Let's try DataParallel and Compare Timings:"""

model = resnet18(weights=ResNet18_Weights.DEFAULT)
model = nn.DataParallel(model)
model.to(torch.device('cuda'))

multi_gpu_time = train_model(model, dataloaders, criterion, optimizer)

print('single_gpu_time: %1.2' %single_gpu_time)
print('multi_gpu_time: %1.2' %multi_gpu_time)

# Labels for the bars
labels = ['Single GPU', 'Multi GPU']

# Values corresponding to the labels
times = [single_gpu_time, multi_gpu_time]

# Creating the bar plot
plt.figure(figsize=(8, 5))  # You can adjust the figure size as needed
plt.bar(labels, times, color=['blue', 'green'])  # Choose colors as you like

# Adding title and labels
plt.title('GPU Time Comparison')
plt.xlabel('Configuration')
plt.ylabel('Time (seconds)')

# Showing the plot
plt.savefig('compare.pdf')

